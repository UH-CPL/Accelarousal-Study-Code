---
title: "Linear Model and ML Model"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

### Configuration
```{r warning=FALSE, echo=FALSE}
GROUP_THRESHOLD = 0.20
TIME_PREV_SECONDS <- 10
TIME_NEXT_SECONDS <- 5
DRIVE_MODE <- 3
```

## Preparation
### Install packages
```{r echo=FALSE}
if(!require("plotly")) {install.packages("plotly")}

# install.packages("latex2exp")
# install.packages("BiocManager") 
# install.packages("corrplot")
# BiocManager::install("EBImage")

if(!require("lme4")){install.packages("lme4")}
if(!require("lmerTest")){install.packages("lmerTest")}
if(!require("nlme")){install.packages("nlme")}
if(!require("formattable")){install.packages("formattable")}
if(!require("xgboost")){install.packages("xgboost")}

library(plotly)
library(lme4)
library(lmerTest)
library(nlme)
library(formattable)
library(xgboost)
```

### Load libraries
```{r warning=FALSE, echo=FALSE}
library(EBImage)
library(ggplot2)
library(stringr)
library(gridExtra)
library(latex2exp)
packageVersion('plotly')
Sys.setenv("plotly_username"="thuynh32")
Sys.setenv("plotly_api_key"="xcSv1yzujDc1IGEwQlr2")
```

### Load data
```{r echo=FALSE}
# persons = c("01", "04", "05", "06", "07", "08", "10", "11", "12") 
# Notes: Cannot read data of Subjects "08", "10", "23", "28" due to no Data for Drive 2 and 3

persons = c("01", "02", "03", "04", "05", "06", "07", "09",
            "12", "13", "15", "16", "17", "18",
            "22", "24", "26", "29", 
            "30", "31", "32", "41")

datas = vector(mode="list", length=length(persons))
datas_baseline = vector(mode="list", length=length(persons))
pp_means = vector(mode="list", length=length(persons))
pp_plots = vector(mode="list", length=length(persons))

names(datas) <- persons
names(datas_baseline) <- persons
names(pp_means) <- persons

for (p in persons) {
  print(paste0("Reading data of subject #", p))
  datas[[p]] <- read.csv(str_interp("../../../data/TT1/preprocessed/T0${person}/T0${person}_Drive_${drive}.csv", list(person=p, drive=DRIVE_MODE)))
  datas_baseline[[p]] <- read.csv(str_interp("../../../data/TT1/preprocessed/T0${person}/T0${person}_Drive_1.csv", list(person=p)))
  
  # Compute the mean
  p_pp_nr <- datas_baseline[[p]]$Perspiration
  p_pp_nr <- p_pp_nr[!is.na(p_pp_nr)]
  pp_means[[p]] <- mean(p_pp_nr)
}
```

### Merge PP Data
```{r echo=FALSE}
extra <- 0.0000000001

all <- data.frame()
all_baseline <- data.frame()
for (p in persons) {
  # On-road
  df_p <- datas[[p]]
  df_p$ppNormalized <- df_p$Perspiration - pp_means[[p]]
  df_p$ppLogNormalized <- log(df_p$Perspiration + extra) - log(pp_means[[p]] + extra)
  df_p$Subject <- p
  
  all <- rbind(all, df_p)
  
  # Baseline
  df_p_baseline <- datas_baseline[[p]]
  df_p_baseline$Subject <- p
  all_baseline <- rbind(all_baseline, df_p_baseline)
}
print(length(all$Time))
print(length(all_baseline$Time))
```

### Common functions
```{r warning=FALSE, echo=FALSE}
calculateMean <- function(l) {
  l <- l[!is.na(l)]
  l <- l[!is.null(l)]
  u <- mean(l)
  # print(l)
  # print(paste("Mean", u))
  return(u)
}

calculateStd <- function(l) {
  l <- l[!is.na(l)]
  l <- l[!is.null(l)]
  return(sd(l))
}
```

### Process the temporal information
```{r warning=FALSE}

temp_all <- all
all <- data.frame()
for (p in persons) {
  # On-road
  p_data <- temp_all[temp_all$Subject == p,]
  n <- nrow(p_data)
  # print(paste(n, " rows"))
  
  if (n > 0) {
    # Add Speed_u, Speed_std, Acc_u, Acc_std, Brake_u, Brake_std, Steering_u, Steering_std
    p_data$Speed_u <- rep(NA, n)
    p_data$Speed_std <- rep(NA, n)
    p_data$Acc_u <- rep(NA, n)
    p_data$Acc_std <- rep(NA, n)
    p_data$Brake_u <- rep(NA, n)
    p_data$Brake_std <- rep(NA, n)
    p_data$Steering_u <- rep(NA, n)
    p_data$Steering_std <-rep(NA, n)
    
    p_data$ppNext <- rep(NA, n)
    
    # Driving stat info of prev seconds
    for (i in TIME_PREV_SECONDS:n) {
      sfrom <- i - TIME_PREV_SECONDS
      sto <- i
      p_data$Speed_u[i] <- calculateMean(p_data$Speed[sfrom:sto])
      p_data$Acc_u[i] <- calculateMean(p_data$Acceleration[sfrom:sto])
      p_data$Brake_u[i] <- calculateMean(p_data$Braking[sfrom:sto])
      p_data$Steering_u[i] <- calculateMean(p_data$Steering[sfrom:sto])
      
      p_data$Speed_std[i] <- calculateStd(p_data$Speed[sfrom:sto])
      p_data$Acc_std[i] <- calculateStd(p_data$Acceleration[sfrom:sto])
      p_data$Brake_std[i] <- calculateStd(p_data$Braking[sfrom:sto])
      p_data$Steering_std[i] <- calculateStd(p_data$Steering[sfrom:sto])
    }
    
    # PP of next seconds
    for (i in 1:(n - TIME_NEXT_SECONDS)) {
      sfrom <- i + 1
      sto <- i + TIME_NEXT_SECONDS
      p_data$ppNext[i] <- calculateMean(p_data$ppLogNormalized[sfrom:sto])
    }
    
    all <- rbind(all, p_data)
  }
}

# Remove NA value
all <- all[!is.na(all$Speed_u) & !is.na(all$Speed_std)
          & !is.na(all$Acc_u) & !is.na(all$Acc_std)
          & !is.na(all$Brake_u) & !is.na(all$Brake_std)
          & !is.na(all$Steering_u) & !is.na(all$Steering_std)
          & !is.na(all$ppNext), ]

print(length(all$Time))
```

\newpage
## Correlation
```{r warning=FALSE, echo=FALSE}
library(corrplot)
library(dplyr)

behavioralColumns <- c("Subject", "Speed (u)", "Speed (std.)", "Acc (u)", "Acc (std.)", "Brake (u)", "Brake (std.)", "Steering (u)", "Steering (std.)")
behavioralMatrix <- matrix(nrow=length(persons), ncol = length(behavioralColumns))

plotCorrelation <- function(p, rowNo=1) {
  pData <- all[all$Subject==p,]
  # Correlation
  pCorrData <- pData %>% select(ppNext, Speed, Acceleration, Braking, Steering,
                                  Speed_u, Acc_u, Brake_u, Steering_u,
                                 Speed_std, Acc_std, Brake_std, Steering_std)
  pCorrData$PP <- pCorrData$ppNext
  pCorrData$ppNext <- NULL
  
  pCorrData <- pCorrData[!is.na(pCorrData$PP),]
  
  col<- rev(brewer.pal(n=10, name="RdBu"))
  corMatrix <-cor(pCorrData)
  # Store to behavioral matrix
  rowCorPP <- corMatrix[nrow(corMatrix),]
  behavioralMatrix[rowNo, ] <<- c(paste0("Subject #", p), 
                                     round(rowCorPP[["Speed_u"]], digits=5),
                                     round(rowCorPP[["Speed_std"]], digits=5),
                                     round(rowCorPP[["Acc_u"]], digits=5), 
                                     round(rowCorPP[["Acc_std"]], digits=5),
                                     round(rowCorPP[["Brake_u"]], digits=5), 
                                     round(rowCorPP[["Brake_std"]], digits=5), 
                                     round(rowCorPP[["Steering_u"]], digits=5), 
                                     round(rowCorPP[["Steering_std"]], digits=5)
                                 )
  
  # Draw
  corrplot(corMatrix, method="circle", type="lower", title = paste0("Correlation Matrix of Subject #", p), mar=c(0,0,4,0), col=col, tl.col="black")
}
```

### 1. Correlation of all Subjects
```{r warning=F, echo=FALSE}
if(!require("RColorBrewer")) {install.packages("RColorBrewer")}
library(RColorBrewer)

# All subject
pCorrData <- all %>% select(ppNext, Speed, Acceleration, Braking, Steering, Speed_u, Speed_std, Acc_u, Acc_std, Brake_u, Brake_std, Steering_u, Steering_std)
pCorrData$PP <- pCorrData$ppNext
pCorrData$ppNext <- NULL

pCorrData <- pCorrData[!is.na(pCorrData$PP),]

col<- rev(brewer.pal(n=10, name="RdBu"))
corMatrix <-cor(pCorrData)
corrplot(corMatrix, method="circle", type="lower", title = paste0("Correlation Matrix of All Subjects"), mar=c(0,0,4,0), col=col, tl.col="black")
```

\newpage
### 2. Correlation of each Subject
```{r warning=FALSE, echo=FALSE}
idx <- 1
for (p in persons) {
  plotCorrelation(p, rowNo = idx)
  idx <- idx + 1
}
```

\newpage
## Grouping
```{r warning=FALSE, echo=FALSE}
behavioralDf <- as.data.frame(behavioralMatrix)
names(behavioralDf) <- behavioralColumns
for (col in behavioralColumns) {
  if (col != "Subject") {
    behavioralDf[,col] <- as.numeric(as.character(behavioralDf[, col]))
  }
}
head(behavioralDf)
```


\newpage
```{r warning=FALSE, echo=FALSE}
colorBlue = "#007fff"
colorRed = "#ff7f7f"
colorGray = "#cccccc"
colorGreen = "#11ff00"

formattable(
    behavioralDf, 
    align=c("c", "r", "r", "r", "r", "r", "r", "r", "r"),
    list(
      `Subject` = formatter("span", style = ~ style(color = "grey",font.weight = "bold")),
      `Speed (u)` = color_tile(colorBlue, colorRed),
      `Speed (std.)` = color_tile(colorBlue, colorRed),
      `Acc (u)` = color_tile(colorBlue, colorRed),
      `Acc (std.)` = color_tile(colorBlue, colorRed),
      `Brake (u)` = color_tile(colorBlue, colorRed),
      `Brake (std.)` = color_tile(colorBlue, colorRed),
      `Steering (u)` = color_tile(colorBlue, colorRed),
      `Steering (std.)` = color_tile(colorBlue, colorRed)
    ) 
)
```

\newpage
### Hierachical Clustering & Grouping
```{r warning=F}
if(!require('dendextend')) {install.packages('dendextend')}
library('dendextend')

CLUSTER_THRESHOLD <- 1.25
NUMBER_OF_CLUSTERS <- 4
CLUSTER_BRANCH_COLORS <- c("red", "blue", "#999999", colorGreen)
CLUSTER_LABEL_COLORS <- c("red", "blue", "black", colorGreen)
MAX_DISTANCE <- 2.5

behavioralMatrixClustering <- as.matrix(behavioralDf)
rownames(behavioralMatrixClustering) <- paste0("#", persons)
distMatrix <- dist(behavioralMatrixClustering)
hresults <- distMatrix %>% hclust
clusters <- cutree(hresults, h=CLUSTER_THRESHOLD)
hc <- hresults %>% as.dendrogram %>% 
   set("nodes_cex", NUMBER_OF_CLUSTERS) %>%
   set("labels_col", value = CLUSTER_LABEL_COLORS, k=NUMBER_OF_CLUSTERS) %>%
   # set("leaves_pch", 19) %>%
   # set("leaves_col", value = c("gray"), k=NUMBER_OF_CLUSTERS) %>%    
   set("branches_k_color", value=CLUSTER_BRANCH_COLORS, k=NUMBER_OF_CLUSTERS)

# Store to a file
dir.create(file.path('../figures/clustering/', paste0('Drive_', DRIVE_MODE)), showWarnings = FALSE)
fname <- str_interp('../figures/clustering/Drive_${drive}/clustering_Prev_${tPre}s_Next_${tNext}s.jpg', list(drive=DRIVE_MODE, tPre=TIME_PREV_SECONDS, tNext=TIME_NEXT_SECONDS)) 
jpeg(fname)
plot(hc,hang = -1, main=paste0("Hierachical Clustering (Previous ", TIME_PREV_SECONDS, "s, Next ", TIME_NEXT_SECONDS, "s)"), ylab="Distance Between Clusters", horiz = F, xlab="Subjects", ylim = c(0, MAX_DISTANCE))
abline(h = CLUSTER_THRESHOLD, lty = 2, )
text(length(persons)/2, CLUSTER_THRESHOLD + 0.15, paste0("Threshold = ", CLUSTER_THRESHOLD), col="orange")
dev.off()

# Print-out
plot(hc,hang = -1, main=paste0("Hierachical Clustering (Previous ", TIME_PREV_SECONDS, "s, Next ", TIME_NEXT_SECONDS, "s)"), ylab="Distance Between Clusters", horiz = F, xlab="Subjects", ylim = c(0, MAX_DISTANCE))
abline(h = CLUSTER_THRESHOLD, lty = 2, )
text(length(persons)/2, CLUSTER_THRESHOLD + 0.15, paste0("Threshold = ", CLUSTER_THRESHOLD), col="orange")
```

```{r warning=FALSE, echo=FALSE}
# Grouping
getClusterName <- function(s) {
  sID <- str_replace(s, "Subject ", "")
  if (str_sub(sID, 1,1) != "#") {
    sID <- paste0("#", sID)
  }
  return(paste0("C", clusters[sID]))
}
behavioralDf <- behavioralDf %>% mutate(Group=getClusterName(Subject))
```

\newpage
```{r warning=FALSE, echo=FALSE}
CLUSTER_COLORS = list(
  C1=colorBlue,
  C2=colorRed,
  C3=colorGray,
  C4=colorGreen
)
textColorformatter <- formatter("span", style = x ~ style(
                                color = ifelse(x >= GROUP_THRESHOLD, colorRed, ifelse(x <= -GROUP_THRESHOLD, colorBlue, "grey"))), 
                                   x ~ icontext(ifelse(x >= GROUP_THRESHOLD, "arrow-up", ifelse(x <= -GROUP_THRESHOLD, "arrow-down", "")), x))

ftable <- formattable(
    behavioralDf, 
    # align=c("c", "r", "r", "r", "r", "r", "r", "r", "r", "c"),
    align=c("c", "r", "r", "r", "r", "r", "r", "r", "r"),
    list(
      `Subject` = formatter("span", style = ~ style(color = "black",font.weight = "bold")),
      `Speed (u)` = textColorformatter,
      `Speed (std.)` = textColorformatter,
      `Acc (u)` = textColorformatter,
      `Acc (std.)` = textColorformatter,
      `Brake (u)` = textColorformatter,
      `Brake (std.)` = textColorformatter,
      `Steering (u)` = textColorformatter,
      `Steering (std.)` = textColorformatter,
      `Group` = formatter("span", style = x ~ style("background-color" = CLUSTER_COLORS[x], "border-radius" = "3px", "padding" = "1px 10px", font.weight = "bold"))
    ) 
)
ftable
```

### Save table
```{r warning=F}
if(!require('htmltools')) {install.packages('htmltools')}
if(!require('webshot')) {install.packages('webshot')}
library(htmltools)
library(webshot)    

exportFormatTable <- function(f, file, width = "100%", height = NULL, 
                               background = "white", delay = 0.2)
{
  w <- as.htmlwidget(f, width = width, height = height)
  path <- html_print(w, background = background, viewer = NULL)
  url <- paste0("file:///", gsub("\\\\", "/", normalizePath(path)))
  webshot(url,
          file = file,
          selector = ".formattable_widget",
          delay = delay)
}

# Export
fname <- str_interp('../figures/correllation/Drive_${drive}/corrTable_Prev_${tPre}s_Next_${tNext}s.jpg', list(drive=DRIVE_MODE, tPre=TIME_PREV_SECONDS, tNext=TIME_NEXT_SECONDS)) 
exportFormatTable(ftable, fname)
```

### Draw all PP
```{r warning=FALSE, echo=FALSE}
plot_all_PP <- plot_ly(all, x = ~Time, y = ~ppNext, name = ~Subject, 
                       type = 'scatter', mode = 'lines', width = 800, line=list(width=1.5),
                       color = ~Subject) %>% layout(title="", xaxis=list(title="Time [s]"), yaxis=list(title=paste0("Avg. Persperation (Next ", TIME_NEXT_SECONDS, " seconds)")))
htmltools::tagList(plot_all_PP)
```


### Draw all Speed
```{r warning=FALSE, echo=FALSE}
plot_all_Speed <- plot_ly(all, x = ~Time, y = ~Speed_u, name = ~Subject, 
                       type = 'scatter', mode = 'lines', width = 800, line=list(width=1.5),
                       color = ~Subject) %>% layout(title="", xaxis=list(title="Time [s]"), yaxis=list(title=paste0("Avg. Speed (Last ", TIME_PREV_SECONDS," seconds)")))
htmltools::tagList(plot_all_Speed)
```






\newpage
## Linear Model
```{r warning=FALSE, echo=FALSE}
layout(matrix(c(1,2,3,4),2,2))

plotLinearModel <- function(p, usePhysiological=F) {
  pData <- all[all$Subject==p,]
  pData <- pData[!is.na(pData$pp),]
  if (usePhysiological) {
    linearModel <- lm(ppLogNormalized ~ Speed_u + Speed_std + Acc_u + Acc_std + Brake_u + Brake_std + Steering_u + Steering_std + HR + BR, data=pData)
    # Diagnostic
    plot(linearModel,caption = paste0("Linear Model (with Physiological) of Subject #", p),which = 1)
    print(summary(linearModel))
  } else {
    linearModel <- lm(ppLogNormalized ~ Speed_u + Speed_std + Acc_u + Acc_std + Brake_u + Brake_std + Steering_u + Steering_std, data=pData)
    # Diagnostic
    plot(linearModel,caption = paste0("Linear Model (without Physiological) of Subject #", p),which = 1)
    print(summary(linearModel))
  }
}

```

### 1. Linear model for all subjects

```{r warning=F, echo=FALSE}
plotLinearModelAll <- function(usePhysiological=F, removeIncompletedSubject=T) {
  linearModelAll <- NULL

  pData <- all[!is.na(all$pp),]
  pData$Subject <- as.factor(pData$Subject)
  if (removeIncompletedSubject) {
    pData <- pData[!(pData$Subject %in% c("11")),]
  }
  
  if (usePhysiological) {
    linearModelAll <- lmer(ppLogNormalized ~ (1|Subject) + Speed_u + Speed_std + Acc_u + Acc_std + Brake_u + Brake_std + Steering_u + Steering_std + HR + BR, data=pData, REML = T)
  } else {
    linearModelAll <- lmer(ppLogNormalized ~  (1|Subject) + Speed_u + Speed_std + Acc_u + Acc_std + Brake_u + Brake_std + Steering_u + Steering_std, data=pData, REML = T)
  }
  
  return(linearModelAll)
}
```

#### All Subjects
```{r warning=FALSE, echo=FALSE}
linearModel_AllSubjects <- plotLinearModelAll(usePhysiological = F, removeIncompletedSubject = F)
plot(linearModel_AllSubjects, main = str_interp("Linear Model (Previous ${tPre}s, Next ${tNext}s)", list(tPre=TIME_PREV_SECONDS, tNext=TIME_NEXT_SECONDS)), ylab="Residual", xlab="Fitted")

# Store plot to a file
fname <- str_interp('./Figures/linearmodel/lm_Prev_${tPre}s_Next_${tNext}s.jpg', list(tPre=TIME_PREV_SECONDS, tNext=TIME_NEXT_SECONDS)) 
jpeg(fname, width = 600)
plot(linearModel_AllSubjects, main = str_interp("Linear Model (Previous ${tPre}s, Next ${tNext}s)", list(tPre=TIME_PREV_SECONDS, tNext=TIME_NEXT_SECONDS)), ylab="Residual", xlab="Fitted")
dev.off()
```

```{r warning=FALSE, echo=FALSE}
print(summary(linearModel_AllSubjects))
print("ANOVA:")
print(anova(linearModel_AllSubjects))
```

\newpage
### 2. Linear model for each subject
```{r warning=FALSE, echo=FALSE}
for (p in persons) {
  plotLinearModel(p, usePhysiological = F)
}
```

```{r warning=FALSE, echo=FALSE}
# for (p in persons) {
#   plotLinearModel(p, usePhysiological = T)
# }
```

```{r warning=FALSE}
n <- length(persons)

perf_df <- data.frame(Subject=character(n + 2),
                      Cls_High=integer(n + 2),
                      Cls_Low=integer(n + 2),
                      Accuracy=double(n + 2),
                      Precision=double(n + 2),
                      Recall=double(n + 2),
                      F1=double(n + 2), 
                      NPV=double(n + 2),
                      AUC=double(n + 2),
                      stringsAsFactors = FALSE)

# Add cluster information to all data
all <- all %>% mutate(Cluster=getClusterName(Subject))
all$Cluster <- as.factor(all$Cluster)

```

```{r warning=FALSE, echo=FALSE}
# install.packages("randomForest")
# install.packages("MLmetrics")
# install.packages("caret")
library(randomForest)
library(ROCR)
library(caret)

# Train
trainAndTestModel <- function(p, idx=1, useData="All", useCluster=F) {
  if (!is.na(p) && idx > 0) {
    pData <- all[all$Subject==p,]
  } else {
    pData <- all
    pData <- pData[complete.cases(pData),]
  }
  
  pData <- pData[!is.na(pData$ppNext), ]
  data_PP_Log_P <- pData$ppNext
  data_PP_Log_P <- data_PP_Log_P[!is.na(data_PP_Log_P)]
  mat_PP_P <- matrix(data_PP_Log_P,nrow = 1,ncol = length(data_PP_Log_P))
  threshold_PP_Log_P <- otsu(mat_PP_P, range=c(min(data_PP_Log_P), max(data_PP_Log_P)))
  
  pp_min = min(data_PP_Log_P)
  pp_max = max(data_PP_Log_P)
  
  pData$clsPP <- ifelse(pData$ppNext >= threshold_PP_Log_P, "High", "Low")
  pData$clsPP <- factor(pData$clsPP)
  
  # print(paste("Subject", p))
  
  # Selected data
  selectedColumns <- c()
  if (useData == "All") {
    selectedColumns <- c('clsPP', 
                       'Speed_u', 'Acc_u', 'Brake_u', 'Steering_u',
                       'Speed_std', 'Acc_std', 'Brake_std', 'Steering_std')
  } else if(useData == "SpeedOnly") {
    selectedColumns <- c('clsPP', 'Speed_u', 'Speed_std')
  } else if(useData == "AccOnly") {
    selectedColumns <- c('clsPP', 'Acc_u', 'Acc_std')
  } else if(useData == "SpeedAcc") {
    selectedColumns <- c('clsPP', 'Speed_u', 'Speed_std', 'Acc_u', 'Acc_std')
  } else {
    print("No data selection applied. Please select a value for param `useData`.")
    return(F)
  }
  
  if (useCluster) {
    selectedColumns = c(selectedColumns, 'Cluster')
  }
  
  pSelected <- pData %>% select(selectedColumns)
  
  nHigh = nrow(pSelected[pSelected$clsPP == "High",])
  nLow = nrow(pSelected[pSelected$clsPP == "Low",])
  
  # print(paste("High =", nHigh))
  # print(paste("Low =", nLow))
  
  # Split dataset
  set.seed(43)
  # smp_size <- floor(0.8 * nrow(pSelected))
  n_folds = 10
  
  folds <- createFolds(factor(pSelected$clsPP), k = n_folds, list = FALSE)
  # folds <- cut(seq(1,nrow(pSelected)), breaks=n_folds,labels=FALSE)
  pSelected$fold <- folds
  
  kf_acc <- double(n_folds)
  kf_prec <- double(n_folds)
  kf_recall <- double(n_folds)
  kf_f1 <- double(n_folds)
  kf_npv <- double(n_folds)
  
  for (i in 1:n_folds) {
    # train_ind <- sample(seq_len(nrow(pSelected)), size = smp_size)
    # train <- pSelected[train_ind, ]
    # test <- pSelected[-train_ind, ]
    
    # test_ind <- which(folds==i, arr.ind=T)
    train <- pSelected[pSelected$fold != i, ] %>% select(-fold)
    test <- pSelected[pSelected$fold == i, ] %>% select(-fold)
    
    # print(paste("Train =", nrow(train), "Pos =", nrow(train[train$clsPP == "High",]), "Neg =", nrow(train[train$clsPP == "Low",])))
    # print(paste("Test =", nrow(test), "Pos =", nrow(test[test$clsPP == "High",]), "Neg =", nrow(test[test$clsPP == "Low",])))
    
    # Model Train
    model <- randomForest(clsPP~., data = train, importance = TRUE, ntree=10)
    # print(model)
    
    # Test
    testX <- select(test, -clsPP)
    predY <- predict(model, testX)
    testY <- test$clsPP
    
    #print(levels(predY))
    #print(levels(testY))
    
    # Evaluate
    # print(table(predY, testY))
    
    kf_acc[i] <- mean(predY==testY)
    kf_recall[i] <- sensitivity(predY, testY)
    kf_prec[i] <- posPredValue(predY, testY, positive = "High")
    kf_f1[i] <- (2 * kf_recall[i] * kf_prec[i]) / (kf_recall[i] + kf_prec[i])
    kf_npv[i] <- negPredValue(predY, testY, positive = "High")
    
    # print(paste("Perf:", kf_acc[i], kf_recall[i], kf_prec[i], kf_f1[i], kf_npv[i]))
  }
  
  # XGB
  param <- list(objective       = "binary:logistic", 
               booster          = "gbtree",
               eval_metric      = "auc",
               eta              = 0.1,
               max_depth        = 10,
               gamma            =0.8,
               min_child_weight = 3,
               subsample        = 1,
               colsample_bytree = 0.5,
               stratified       = F
  )
  pSelected <- pSelected %>% mutate(clsPP=ifelse(clsPP=="High", 1, 0))
  
  aucs = c()
  if (!useCluster) {
    xgb_m = xgb.cv(   params               = param,
                      data = as.matrix(pSelected %>% select(-clsPP)) ,
                      label =  pSelected$clsPP,
                      nrounds             = 500,
                      verbose             = F,
                      prediction          = T,
                      maximize            = T,
                      nfold = n_folds,
                      metrics  = "auc",
                      early_stopping_rounds = 100,
                      scale_pos_weight = 1)
    aucs =  c(aucs,as.numeric(xgb_m$evaluation_log[xgb_m$best_iteration,"test_auc_mean"]))
  }
  
  # Get average performance
  acc <- mean(kf_acc)
  prec <- mean(kf_prec)
  recall <- mean(kf_recall)
  f1 <- mean(kf_f1)
  npv <- mean(kf_npv)
  auc <- mean(aucs)
 
  # Return 
  rtn <- list(
    accuracy=acc,
    recall=recall,
    precision=prec,
    f1=f1,
    npv=npv,
    auc=auc
  )
  
  # Store to common variable
  if (!is.na(p) && idx > 0) {
    perf_df$Subject[idx] <<- paste0("Subject #", p)
    perf_df$Cls_High[idx] <<- nHigh
    perf_df$Cls_Low[idx] <<- nLow
    perf_df$Accuracy[idx] <<- acc
    perf_df$Precision[idx] <<- prec
    perf_df$Recall[idx] <<- recall
    perf_df$F1[idx] <<- f1
    perf_df$NPV[idx] <<- npv
    perf_df$AUC[idx] <<- auc
  } else {
    idx <- n + ifelse(useCluster, 2, 1)
    perf_df$Subject[idx] <<- ifelse(useCluster, "All (w. Cluster)", "All (No Cluster)")
    perf_df$Cls_High[idx] <<- nHigh
    perf_df$Cls_Low[idx] <<- nLow
    perf_df$Accuracy[idx] <<- acc
    perf_df$Precision[idx] <<- prec
    perf_df$Recall[idx] <<- recall
    perf_df$F1[idx] <<- f1
    perf_df$NPV[idx] <<- npv
    perf_df$AUC[idx] <<- auc
  }
  
  # print(rtn)
  # testDf <- data.frame(obs=testY, pred=predY)
  # print(twoClassSummary(testDf, lev=levels(testDf$obs)))
  # print(prSummary(testDf, lev=levels(testDf$obs)))
}
```

```{r}
# trainAndTestModel("08", idx=2)
```

\newpage
## Random Forest model to predict class of PP (High, Low)
Note: 

- I used Otsu algoritm to mark the class of PP, and then use driving data (Speed, Acc, Brake, Steering) to predict the class in 5 seconds.
- For each subject, I exclusively trained and tested a ML model to predict the class of PP.
- Applied Cross validation with stratified KFold=10.
- Used temporal information of data within last 5 seconds.
- Data of Subject#1 and #11 is so significant imbalance that need more evaluation (Here, I used F1 metric to evaluate the result).

### 1. ML Model 1: Use all driving data (includes Speed, Accelertor, Brake, Steering)
```{r warning=FALSE, echo=FALSE}
i <- 1
for (p in persons) {
  trainAndTestModel(p, idx = i, useData = "All")
  i <- i + 1
}

# Train model for all subjects
trainAndTestModel(NA, idx = 0, useData = "All")
trainAndTestModel(NA, idx = 0, useData = "All", useCluster=T)

head(perf_df, n = length(persons))
```

```{r warning=F}
# Export
ftable_perf <- formattable(
    perf_df, 
    align=c("c", "r", "r", "r", "r", "r", "r", "r", "r"),
    list(
      `Subject` = formatter("span", style = ~ style(color = "black",font.weight = "bold"))
    ) 
)
fname_perf <- str_interp('./Figures/mlperf/perf_Prev_${tPre}s_Next_${tNext}s.jpg', list(tPre=TIME_PREV_SECONDS, tNext=TIME_NEXT_SECONDS)) 
exportFormatTable(ftable_perf, fname_perf)
ftable_perf
```


```{r echo=FALSE}
# To run over
```
